## MySQL

#### 主键索引

主键索引的叶子结点存储的是一条完整的数据，非主键索引除了索引值外，还存储了主键值，因此表的主键尽量不要太大，不然很占空间。

因此在查询的时候，如果命中的是非主键索引，他会现在非主键索引上找到对应的主键索引值，再去查主键索引获得一条完整的数据，这个过程就叫做回表。

### 索引类型

普通索引、唯一索引、主键索引、联合索引、全文索引

#### MyISAM与InnoDB的区别

| InnoDB                                 | MyISAM                                                       |
| -------------------------------------- | ------------------------------------------------------------ |
| 支持事务                               | 不支持事务                                                   |
| 支持主键和外键                         | 不支持主键和外键                                             |
| 主键聚集索引，索引和数据文件绑定在一起 | 非聚集索引，索引和数据文件是分离的，索引保存的是数据文件的指针 |
|                                        |                                                              |
|                                        |                                                              |
|                                        |                                                              |
|                                        |                                                              |
|                                        |                                                              |

### MVCC

事务开始时创建快照readview，快照中维护当前事务id以及指向上一个readview版本的指针，访问时通过比较readview数据，来寻找自己访问的数据版本。

可重复读：只会创建一个readview版本，所有操作都在这个版本进行，其他事务来了只会访问前一个版本，

读已提交：会创建多个readview版本。

综上述：可重复读性能较高。



### MySQL主从同步原理

MySQL主从复制通过三个线程实现，master、slavery、SQL

- 主数据库将所有的数据变更记录到binlog文件中
- log dump线程在binlog文件有变化的时候读取其内容发送到从节点
- 从节点IO线程接受binlog内容，并将其写入到relay log文件中
- 从节点SQL线程读取relay log文件对数据进行重放，保证数据一致性

主从节点通过binlog文件+position偏移量来确定主从同步的位置。









### MySQL的锁

按粒度分：行锁、表锁、间隙锁

还可以分为：共享锁（读锁）、排它锁（写锁）

还可以分为：乐观锁、悲观锁

- 

## Spring

### spring是什么？

是一个轻量级开源的框架，他是一个容器框架，用来装javabean，可以加快企业开发。

从功能上来说，他是一个轻量级具有控制反转和面向切面编程的容器框架：

#### AOP是什么？

面向切面编程，将程序中的交叉业务逻辑封装成一个切面，然后注入到目标对象中，AOP可以对某些对象的功能做增强，可以在某个方法执行之前额外执行一些其他的逻辑。

#### IOC是什么？

IOC是一个map容器。控制反转、依赖注入、容器概念

### BeanFactory和ApplicationContext

ApplicationContext是BeanFactory的一个子接口，ApplicationContext提供了更完整的功能

- 继承了MessageSource接口，支持国际化
- 统一的资源文件访问方式
- 提供在监听器注册bean事件
- 同时加载多个配置文件

BeanFactory采用了延迟加载，只有在用到的时候才会加载对象，不太容易发现问题

ApplicatonContext采用的是统一加载，提前加载可能会占用空间，当配置bean多了，启动会比较慢

### SpringSecurity

如果直接导入包，不加任何配置，那在用浏览器访问接口的时候会跳到security自带的login页面，用户名默认user，随机密码在console中会被打印

1. 导入security包

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

```

2. 继承类UsernamePasswordAuthenticationFilter，重写方法



3. 设置用户登录名和密码的三种方式

- 配置文件设置

  

- 配置配置类

- 自定义编写代码从数据库中读取

### **@RequestBody**

接收的参数是来自requestBody中，即请求体。  一般用于处理非 Content-Type: application/x-www-form-urlencoded编码格式的数据，将json转化为对象

### **@ResponseBody**

@ResponseBody的作用其实是将java对象转为json格式的数据

### @RequestMapping

### **@RequestParam**

### IOC

控制反转、依赖注入

### AOP

AOP，面向切面编程，作为面向对象的一种补充，将公共逻辑（事务管理、日志、缓存等）封装成切面，跟业务代码进行分离，可以减少系统的重复代码和降低模块之间的耦合度。切面就是那些与业务无关，但所有业务模块都会调用的公共逻辑。

面向切面编程，通过预编译和运行时动态代理，日志记录、性能统计、安全控制、事物管理、异常处理等

BeanDefinitionReader:从yml、xml等配置文件中读取bean的配置信息

BeanFactory：获取Bean容器的root接口

PostProcessor：为了扩展实现，

BeanFactoryPostProcessor：可以在BeanDefinitionReader读取到bean的配置信息后修改信息，对BeanFactory中的对象做拓展工作，主要是BeanDefinition对象，比如解析@Import注解

BeanPostProcessor：AOP代理在这里实现

FactoryBean：生产特殊的对象；有isSingleton、getObject、getObjectType方法

运行流程：

1、prepareRefresh() 创建BeanFactory，创建容器

2、prepareBeanFactory() 读取配置文件，生成BeanDefinition：属性值：beanDefinitionMap，beanDefinitionNames，读取完了后，配置了几个bean在map中就有几个beanDefinition

3、postProcessBeanFactory() 扩展，对beanDefinition信息做扩展，需要自定义

4、invokeBeanFactoryPostProcessors：唤醒factory processor作为bean注册

5、registerBeanPostProcessors：注册bean processors

6、DefaultSingletonBeanRegistry

属性设置方法：populateBean()

### springbean生命周期

根据beanname使用默认的构造方法->创建对象->依赖注入-> 初始化前(PostContruct) ->初始化->初始化后(AOP)->代理对象->bean

1、解析类得到BeanDefinition

2、如果有多个构造方法，则要推断构造方法

3、确定好构造方法后，实例化一个对象，设置对象属性populateBean

4、对对象中加入了@Autowired注解的属性进行注入

5、回调Aware方法，比如BeanNameAware，BeanFactoryAware

6、调用BeanPostProcessor的初始化前方法

7、调用初始化方法

8、调用BeanPostProcessor的初始化后的方法，在这里进行AOP

9、如果当前创建的bean是单例的，则将其放入单例池中

10、使用bean

11、spring容器关闭时调用DisposableBean中的destory方法

#### bean的作用域

singleton：单例

prototype：每一个getbean都会提供一个实例

request：单个请求复用一个实例

session：一个session复用一个实例

application：同一个ServletContext的声明周期中复用一个实例

websocket：websocket的生命周期中复用一个实例

global-session：全局作用域

### 单例bean是线程安全的吗

有状态：有数据保存

无状态：无数据保存

不是线程安全的，如果要保证线程安全，使用ThreadLocal把变量变为线程私有，如果bean实例变量或类变量需要在多个线程中共享，那么只能使用synchronized、lock、CAS等来加锁实现；

### 框架中用到了哪些设计者模式

工厂设计者模式

单例模式

动态代理

### 事务的实现方式和原理以及隔离级别

1.编程式自己写代码实现

2.声明式

隔离级别：未提交读、提交读不可重复读、可重复读、可串行化

### 事务机制

- spring事务是基于数据库事务和AOP机制的
- 对使用了@Transactional注解的Bean，Spring会先创建一个代理对象作为Bean
- 如果加了，则利用事务管理创建一个数据库连接
- 并且修改数据库连接的autocmmit属性为false，禁止自动提交
- 执行当前方法，执行完后没有异常直接提交
- 有异常回滚事务，且是需要回滚的就回滚事务，否则仍然提交事务
- spring事务的隔离级别对应的就是数据库的隔离级别
- spring事务的传播机制是spring事务自己实现的，也是spring事务中最复杂的。
- spring事务的传播机制是基于数据库连接来做的，一个数据库连接一个事务，如果传播机制配置需要新开一个事务，实际上就是先建立一个数据库连接，在此新数据连接上执行sql

#### 什么时候@Transactional失效

#### 事务传播机制

假如a方法调用了b方法

REQUIRED：b加了这个注解，如果a里有没有事务，则b新建事务，若a有事务，则加入a的事务

SUPPORTS：如果a有事务，则b加入事务；如果a没有事务，则以非事务运行

MANDATORY：如果a有事务，则b加入事务，如果a没有事务，则抛出异常

REQUIRES_NEW：创建一个新事务，如果a有事务，将a事务挂起，等b执行完后，再运行a事务

NOT_SUPPORTED：以非事务运行，如果a存在事务，则挂起a事务，b以非事务运行结束后，再运行a事务

NEVER：不使用事务，如果a有事务，则抛出异常

NESTED：如果a有事务，则

#### 事务什么时候失效

Spring事务的原理是AOP，进行了切面增强

1、发生了自调用，类里面使用了this调用本类方法，此时这个this不是代理类，而是userService本身，所以会发生失效，如果要避免就将userService这个对象变成代理类。

2、方法不是public，@Transactional只能用在public方法上，如果非要用，需要开启@AspectJ代理模式

3、数据库本身不支持事务

4、没有被Spring管理

5、异常被try吃掉，事务不会滚

#### 什么是Bean自动装配，有哪些方式

spring.xml中有五种装配方式：

- no - 缺省情况下通过ref属性手动设定
- byName根据bean的属性名称来进行自动装配 set注入
- byType根绝bean类型自动注入
- contructor - 类似于byType，用于构造器的参数。如果一个bean与构造器参数类型相同，则进行自动装配，否则异常
- autodetect-如果有默认构造器，则通过constructor方式进行装配，否则使用byType装配
- @Autowired装配

#### 自动装配？

启动starter的时候解析@Import

当对象不想经过传统的bean注册流程来生成对象时，可以将其实现FactoryBean接口，此时在加载的时候会判断是否实现了FactoryBean接口，实现了就不会按照传统的getBean()方法来获取bean对象

#### Spring Boot、Spring MVC、Spring有什么区别

spring是一个ioc容器，用来管理bean

springmvc是spring对web框架的一个解决方案，通过一个统一的servlet来接受所有请求，定义了一套路由策略来处理请求。

springboot是spring提供的一个快速开发工具包，让程序员能够更快的开发spring+springmvc应用

### spring解决跨域问题

#### SpringMVC的工作流程

- 首先接受用户请求到DispatcherServlet
- DispatcherServlet收到请求调用HandlerMapping处理器映射器
- HandlerMapping根据url找到具体的处理器，生成处理器及处理器拦截器返回给DispatcherServlet
- DispatcherServlet调用HandlerAdapter处理器适配器
- HandlerAdapter经过适配器调用具体的处理器（Controller）
- Controller执行完成后返回ModelAndView
- HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet
- DispatcherServlet将ModelAndView传给ViewResolver视图解析器
- DispatcherServlet根据view进行渲染视图
- DispatcherServlet响应用户

#### SpringMVC的九大组件

- HandlerMapping：处理器映射器
- HandlerAdapter：适配器
- HandlerExceptionResolver：
- ViewResolver
- RequestToViewNameTranslator
- LocaleResolver
- ThemeResolver
- MultipartResolver
- FlashMapManager

#### 自动配置原理

@Import+@Configuration+Spring spi

自动配置由各个starter提供，使用@Configuration+@Bean定义配置类，放到META-INF/spring.factories下使用spring spi扫描META-INF/spring.factories下的配置类

使用@Import导入自动配置类，在配置类里面有个selectImports方法来去对应的包里面加载spring.factories里的类到容器中。

#### 如何理解Spring Boot中的starter

starter实际上导入的是一个jar包，写一个@Configuration配置类，将这些bean定义在里面，然后在starter包的META-INF/spring.factories中写入该配置类，springboot会按照约定来加载该配置类

开发人员只需要相应的starter包依赖进应用，进行相应的属性配置，就可以进行代码开发使用对应的功能。

#### 自定义一个starter

1.引入依赖

```XML
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-autoconfigure</artifactId>
  <version>2.7.0</version>
  <scope>compile</scope>
</dependency>
```

2.开发自己的逻辑代码

3.在resources文件夹下新建META-INF/spring.factories文件，在里面配置类全名：

```XML

```

#### 读取配置文件参数

1.@Value注解

2.在Demo类加上ConfigurationProperties(prefix="[user.name](http://user.name)")，并且在config类中配置对应的@EnableConfigurationProperties(Demo.class)，此时会直接从配置文件中读取带有user.name前缀的参数，自动注入到类中的对应名称的变量

#### SpringCloud和Dubbo的区别

底层协议：SpringCloud基于http协议，Dubbo基于Tcp协议，决定了Dubbo的性能相对会比较好

注册中心：SpringCloud使用Eureka，Dubbo推荐使用Zookeeper

模型定义：Dubbo将一个接口定义为一个服务，SpringCloud则是将一个应用定义为一个服务

SpringCloud是一种生态，而Dubbo是SpringCloud生态中关于服务调用的一种解决方案

#### SpringCloud核心组件及其作用？

服务注册与发现：Netflix Eureka、Nacos

客户端负载均衡：Ribbon

服务端熔断：Hystrix

服务网关：spring cloud gateway

服务接口调用：Feign

配置中心：spring cloud config

#### Spring后置处理器的作用

#### 解决spring循环依赖

三级缓存、（在循环对象的构造方法上加上注解）

实例化bean对象，获取BeanDefinition DefaultSingletonBeanRegistry的属性：

- singletonObjects：一级缓存
- earlySingletonObjects：二级缓存
- singletonFactories：三级缓存

每次获取bean对象的时候先从一级缓存中取值。

RuntimeBeanReference类型

a对象创建到实例化但未初始化的时候，创建个RuntimeBeanReference对象，并将RuntimeBeanReference放入到三级缓存中，进行a的属性赋值，此时在一级缓存中未找到b对象，所以进行b对象的创建，当b进行到实例化为初始化的时候对b对象的a属性进行赋值，先去一级缓存中寻找，找不到去二级三级缓存中找a对象，对b对象的a属性赋值a后，将a对象放到二级缓存，把三级缓存中的a删除。此时的b对象实例化和初始化完成，将b对象放入到一级缓存中，从三级缓存删除。 此时将a对象的b属性进行赋值。此时把a从二级缓存中删除，放到一级缓存中。

上面放入二级缓存和三级缓存的都是ObjectFactory对象

属性赋值-populateBean

容器对象属性赋值-invokeAwareMethods

初始化-invokeInitMethods

**一级缓存**：放成品

**二级缓存**：放半成品

**三级缓存**：放lambda表达式

### 三级缓存怎样实现AOP？

### Spring中实现了哪些设计模式？

工厂模式：BeanFactory

模板模式：各种BeanFactory以及ApplicationContext实现中；模板方法就是抽取逻辑代码类似于写接口

代理模式：AOP

策略模式：加载资源文件的方式；

单例模式：默认bean对象

观察者模式：各种ApplicationListener

适配器模式：Adapter

装饰者模式：Wrapper

因此一级缓存中放的是完成实例化和初始化的对象，二级缓存放的是实例化结束，但未初始化的对象。三级缓存中放的是，实例化但未初始化的对象是一个RuntimeBeanReference的匿名内部类

为什么使用三级缓存？二级缓存不行吗

@Lazy注解：解决构造方法造成的循环依赖问题，比如在A构造方法中传入B对象作为参数

二级缓存可以解决对象之间的普通的引用循环，二级缓存会保存new出来的不完整对象，当在单例池中找不到对象时，可以在二级缓存中找，循环依赖，

#### JDK代理和cglib代理

代理模式是指通过对象A持有另一个对象B，并且具有B的行为。如果A对象固定持有B对象，那么这就是静态代理，如果A代理的对象是不确定的，那么就是动态代理。

jdk动态代理：通过java的反射机制生成一个实现代理接口的匿名类；调用方法时用invokeHandler来处理

cglib动态代理：利用asm开源包，对代理类的class文件操作，修改其字节码生成子类来处理。

1、如果对象实现了接口，默认使用jdk动态代理实现AOP

2、如果对象实现了接口，可以强制使用cglib实现AOP

3、如果没有实现接口，则强制使用cglib实现AOP

- jdk创建对象速度远大于cglib，
- cglib执行速度略大于jdk，比较适合单例
- 由于cglib大部分类直接对java字节码操作，所以生成的类会一直存在永久堆中，容易发生outofmemory
- spring默认使用jdk代理，如果类没有接口，则使用cglib

```xml
<dependency>

    <groupId>org.springframework.boot</groupId>

    <artifactId>spring-boot-autoconfigure</artifactId>

    <version>2.7.0</version>

    <scope>compile</scope>

</dependency>
```





## 操作系统

AIO、BIO、NIO

#### CPU中断

中断的本质是需要操作系统介入，开展管理工作。

中断是系统响应硬件设备请求的一种机制，他会打断进程的正常调度，然后调用内核中的中断处理程序来响应设备请求。

首先中断发生的时候，会在中断禁止模式下运行，主要处理和硬件密切相关或时间敏感的工作，快速处理防止长时间阻断其他中断

软中断：执行到INT指令的时候发生的中断。

硬中断：由硬件产生的中断，比如磁盘网卡等

#### **1、进程、线程、协程以及它们的区别**

- 进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；
- 线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的 实时性，实现进程内部的并发；
- 一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；
- 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。
- 协程比进程、线程更加轻量级，不是被系统内核所管理，而是由用户程序所控制，不用切换状态，节省资源，本质上是函数，协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来执行。

#### **2、进程间的通信的几种方式**

信号、信号量、管道、消息队列、共享内存、套接字

#### **3、线程同步的方式**

互斥量、信号量、事件

#### **4、什么是死锁？死锁产生的条件？**

互斥：一个资源只能被一个进程使用

不可抢占：进程未使用完资源不能抢占

占有并等待：

循环等待：

避免死锁最简单的方法就是阻止循环等待条件

#### 什么是上下文切换

#### DCL双重校验锁

#### 线程调度策略

优先级调度、时间片轮转、抢占式调度、多级反馈队列调度算法、高响应比优先调度算法

### CPU作业调度算法

先来先执行

短作业优先

优先级调度

高响应比优先：（等待时间+执行时间）/执行时间

轮转调度

多级队列调度

多级反馈队列调度

![img](https://secure2.wostatic.cn/static/kMRqWtzhxURM9XocJt1NAP/image.png)

#### **5、进程有哪几种状态？**

#### **6、线程有几种状态？**

NEW、RUNNABLE、RUNNING、BLOCKED、DEADED

#### **7、分页和分段有什么区别（内存管理）？**

#### **8、操作系统中进程调度策略有哪几种？**

FIFO、优先级、最短优先、时间轮转、多级队列

#### **9、说一说进程同步有哪几种机制**

#### 3.6 CPU 寻址了解吗?为什么需要虚拟地址空间?

现在的CPU寻址使用的是虚拟寻址的寻址方式，CPU需要将虚拟地址转化成物理地址，这样才能访问到真实的内存空间。完成虚拟地址到物理地址的转化硬件是CPU中的内存管理单元的硬件。如果没有虚拟地址，用户可以直接访问物理地址，寻址内存中的每个字节，这样容易破坏操作系统，造成系统崩溃。

虚拟寻址空间的好处：一遍程序

1、程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区

立即寻址、直接寻址、寄存器寻址、寄存器间接寻址、基址寻址、变址寻址

#### 虚拟内存、分页内存管理、多级分页、局部性原理

#### 零拷贝

正常拷贝

![img](https://secure2.wostatic.cn/static/2UTzNhWFL7KwJ87prjJhjR/image.png)

零拷贝：节省了一次

![img](https://secure2.wostatic.cn/static/7qwtyrXYjWdCUbhSr2zCMk/image.png)

### cut、sort、wc、sed、awk

```Bash
# 将filename文件中内容的每行用:分割，并显示分割后的前五列
cut -d ':' -f1,2,3,4,5 filename

# 对文本内容排序，按行
sort filename
# 将文本行按:分割， 按照第二列大小对文件内容进行升序排序，此时是字符串字典序
sort -t ':' -k2 filename 
# 将文本行按:分割， 按照第二列大小对文件内容进行降序排序，此时是字符串字典序
sort -t ':' -k2 -r filename 
# 将文本行按:分割， 按照第二列大小对文件内容进行排序，此时将第二列转化为数字排序
sort -t ':' -k2 -n filename

# 统计文件数据
wc filename

# 查找文件内容, 从filename中寻找huangda
grep huangda filename
# 忽略大小写在filename中寻找huangda
grep -nvi huangda filename --color=auto
# 使用正则表达式匹配内容
grep -E "[1-9]+" filename --color=auto

# sed目的是操作文本
```

### 主机之间免密钥登陆

```Bash
$n  第n个参数
$?  上一个执行的返回值
${#aa} aa的字符串长度
$#  参数数量
$!  上一个脚本或程序的pid
$0  脚本名字
|   管道
&&  并且
||  或者
$*  取出脚本所有参数，加双引号后，其内容相当于一个整体
$@  取出脚本所有参数，加双引号后，其内容相当独立
```

## 计算机网络

注解：@Target、@Retention、@Documented

对象的私有属性需要field.setAccessible(true);

ApplicationContext是BeanFactory的实现类

BeanFactory：BeanDefinition是存在BeanFactory中的，如果想完成对BeanDefinition的拓展，那么只要获取到BeanFactory就可以对其进行扩展

1、IOC创建过程

2、bean实例化过程

3、循环依赖

4、AOP

5、事件发布监听

为什么udp有首部长度，而tcp没有。

tcp面向字节流，udp面向报文

#### **1、Http和Https的区别**？

Http协议：定义了客户端如何向服务端请求以及服务端如何向客户端响应的协议。它采用了请求响应模式，客户端向服务端发送一个请求报文，请求报文包含请求方法，URL、版本、请求头数据和请求数据。

http协议工作流程如下：

- 首先客户端向服务端建立发送连接请求
- 建立连接后客户端向服务端发送http请求
- 服务端接收到请求处理并响应请求后，断开连接
- 客户端接收到服务端的响应，解析服务端的数据，渲染页面

请求方法有POST、GET、DELETE、PUT等

返回的状态有

1XX:请求被接受，继续处理，无错误

2XX:成功处理

3XX:重定向

4XX:请求错误，比如页面丢失什么的

5XX:服务器内部错误

[Http](https://so.csdn.net/so/search?q=Http&spm=1001.2101.3001.7020)协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：

**端口号** ：HTTP 默认是 80，HTTPS 默认是 443。

**UTL 前缀** ：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`。

**安全性和资源消耗** ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。

#### **2、对称加密与非对称加密**

对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。

#### **3、三次握手与四次挥手**

(1). 三次握手(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)：

第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。

第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

(2). 四次挥手(我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧)：

第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。

第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

#### **4、为什么TCP链接需要三次握手，两次不可以么，为什么？**

#### **5、TCP协议如何来保证传输的可靠性**

数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；

对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；

丢弃重复数据：对于重复数据，能够丢弃重复数据；

应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；

超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；

流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

#### **6、客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？**

1)、DDos 攻击：客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

2)、DDos 预防(没有根治方法，除非不使用TCP)：限制同时打开SYN半链接的数目、缩短SYN半链接的Time out 时间、关闭不必要的服务

#### **8、TCP与UDP的区别**

TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：

TCP是面向连接的，UDP是无连接的；

TCP是可靠的，UDP是不可靠的；

TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；

TCP是面向字节流的，UDP是面向报文的；

TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；

TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；

#### **9、TCP的拥塞处理**

拥塞控制就是 防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。注意，**拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。**

1). **慢启动：** 不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;

2). **拥塞避免：** 拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。

3). **快重传**：快重传要求接收方在收到一个 失序的报文段 后就立即发出 重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

4). **快恢复**：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。

#### TCP的流量控制

滑动窗口：

#### **10、从输入网址到获得页面的过程**

#### **11、Session、Cookie 与 Application**

#### **12、SQL 注入**

解决方法：预编译，mybatis中使用#{}来绑定变量作为占位符，可以防止sql注入

#### **13、 XSS 攻击**

XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。

主要原因：过于信任客户端提交的数据！

解决办法：不信任任何客户端提交的数据，只要是客户端提交的数据就应该先进行相应的过滤处理然后方可进行下一步的操作。

#### **14、OSI网络体系结构与TCP/IP协议模型**

物理层：传递二进制流

数据链路层：在物理层传递二进制流的基础上，在通信实体之间建立连接，传递以帧为单位的数据

网络层：执行路由选择算法，为报文分组选择最合适的路径

传输层：向用户提供端到端的服务，透明的传送报文

会话层：

表示层：

应用层：

UDP：DHCP、DNS、ARP

#### **15、TCP和UDP分别对应的常见应用层协议**

1). TCP对应的应用层协议

FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。

Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。

SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。

POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。

HTTP：从Web服务器传输超文本到本地浏览器的传送协议。

2). UDP对应的应用层协议

DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。

SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。

TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。

#### **17、IP地址的分类**

- A类地址：以0开头，第一个字节范围：0~127；
- B类地址：以10开头，第一个字节范围：128~191；
- C类地址：以110开头，第一个字节范围：192~223；
- D类地址：以1110开头，第一个字节范围为224~239；
- E类地址：以1111开头，保留地址

#### **18、IP地址与物理地址**

#### **21、 常见状态码及原因短语**

#### **22、请简单说一下你了解的端口及对应的服务？**

#### 23、HTTP 1.0 vs HTTP 1.1（应用层）

- **连接方式** : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。 **状态响应码** : HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，`100 (Continue)`——在请求大资源前的预热请求，`206 (Partial Content)`——范围请求的标识码，`409 (Conflict)`——请求与当前资源的规定冲突，`410 (Gone)`——资源已被永久转移，而且没有任何已知的转发地址。 **缓存处理** : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。 **带宽优化及网络连接的使用** :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 **Host头处理** : HTTP/1.1在请求头中加入了`Host`字段

#### 24、ARP协议

ARP解决了同一个局域网上的主机和路由器IP和MAC地址的解析。

- 每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。
- 当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。
- 网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址。
- 源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。
- 如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

#### 25、DNS 的解析过程？

- 浏览器搜索**自己的DNS缓存**
- 若没有，则搜索**操作系统中的DNS缓存和hosts文件**
- 若没有，则操作系统将域名发送至**本地域名服务器**，本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则依次向**根域名服务器、顶级域名服务器、权限域名服务器**发起查询请求，最终返回IP地址给本地域名服务器
- 本地域名服务器将得到的IP地址返回给**操作系统**，同时自己也**将IP地址缓存起来**
- 操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来
- 浏览器得到域名对应的IP地址

#### 26、HTTPS原理

首先是TCP三次握手，然后客户端发起一个HTTPS连接建立请求，客户端先发一个`Client Hello`的包，然后服务端响应`Server Hello`，接着再给客户端发送它的证书，然后双方经过密钥交换，最后使用交换的密钥加解密数据。

### 26、路由选择协议

链路状态选择算法：全网泛洪+迪杰斯特拉算法，收敛快，OSPF

距离矢量算法（好消息传得快，坏消息传的慢、异步、分布）：收敛慢，RIP

水平分裂：P35 5.2 路由选择算法   1:24:30 ，解决距离矢量算法中坏消息传的慢的问题

自治系统算法：IS-IS

边界网关协议：BGP（eBGP、iBGP）

#### HTTP 1.1

- 长连接，流水线，使用connection:keep-alive使用长连接；
- 请求管道化；
- 增加缓存处理(新的字段如cache-control)；
- 增加Host字段，支持断点传输等；
- 由于长连接会给服务器造成压力。

#### HTTP 2.0

- 二进制分帧；
- 多路复用(或连接共享)，使用多个stream，每个stream又分帧传输，使得一个tcp连接能够处理多个http请求；
- 头部压缩，双方各自维护一个header的索引表，使得不需要直接发送值，通过发送key缩减头部大小；
- 服务器推送(Sever push)。

#### HTTP 3.0

- 基于google的QUIC协议，而quic协议是使用udp实现的；
- 减少了tcp三次握手时间，以及tls握手时间；
- 解决了http 2.0中前一个stream丢包导致后一个stream被阻塞的问题；
- 优化了重传策略，重传包和原包的编号不同，降低后续重传计算的消耗；
- 连接迁移，不再用tcp四元组确定一个连接，而是用一个64位随机数来确定这个连接；
- 更合适的流量控制。



## SpringCloud

### Nacos

- 服务注册
- 服务心跳
- 服务同步
- 服务发现
- 服务健康检查

Nacos可以通过nginx来配置集群，但是注意需要将nacos用mysql数据源存储模式来保证集群节点的信息一致性

### 自定义LoadBalance负载均衡器

1. 参照RoundRobinLoadBalancer类重写其中的getInstanceResponse方法，如果想要实现随机负载均衡访问策略，则修改下列代码，将getInstanceResponse方法中的顺序访问改为随机数

```Java
// int pos = Math.abs(this.position.incrementAndGet());
Random random = new Random();
int pos = random.nextInt(instances.size());
```

1. 创建config将其注入到容器中

```Java
@Configuration
public class LoadBalanceConfig {

    @Bean
    @LoadBalanced
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder.build();
    }

    @Bean
    ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(Environment environment,
                                                            LoadBalancerClientFactory loadBalancerClientFactory) {
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        // 返回自定义负载均衡器
        return new HDTLoadBalance(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class), name);
    }
}
```

1. 在主启动类上配置默认的负载均衡器

```Java
@SpringBootApplication
@LoadBalancerClients(defaultConfiguration = {LoadBalanceConfig.class})
public class ServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceApplication.class, args);
    }
}
```

### openFeign调用规则

1. 导入openfeign依赖

```Java
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

1. 定义数据接口

```Java
// 这里的product为另一个product服务的/product数据接口
@FeignClient(name = "product")
public interface ProductFeignService {
    @RequestMapping("/product")
    public String product();
}
```

1. 启动类配置EnableFeignClients

```Java
@SpringBootApplication
@LoadBalancerClients(defaultConfiguration = {LoadBalanceConfig.class})
@EnableFeignClients
public class ServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceApplication.class, args);
    }
}
```

1. 有配置feign日志的需要，默认是NONE

```Java
// @Configuration 加了这个注解则说明是全局配置，不加则需要在下面进行局部配置
public class ProductFeignConfig {
    @Bean
    public Logger.Level feignLoggerLevel(){
        /**
         * FULL：不记录任何值
         * BASIC：仅记录请求方法、URL、响应状态以及执行时间
         * HEADERS：记录BASIC的基础上，记录请求和响应的header
         * FULL：记录请求响应的header、body和元数据
         */
        return Logger.Level.FULL;
    }
    
    /**
     * 设置服务的访问超时等配置
     * @return
     */
    @Bean
    public Request.Options options() {
        return new Request.Options(3000, TimeUnit.MILLISECONDS,3000,
                TimeUnit.MILLISECONDS, true);
    }
}
```

1. 如果需要局部配置配置日志，则在调用接口添加configuration属性

```Java
@FeignClient(name = "product", configuration = ProductFeignConfig.class)
public interface ProductFeignService {
    @RequestMapping("/product")
    public String product();
}
```

1. 由于springboot默认的日志输出是info，所以feign的debug日志会被吞掉，所以在配置文件中设置日志级别

```YAML
logging:
  level:
    # 这个key为自己feign所在的的包名
    com.example.service.feign: debug

# feign局部日志配置
feign:
  client:
    config:
      product: # 这个为自己需要调用的的微服务名称
        loggerLevel: BASIC
```

1. 自定义拦截器

```Java
import feign.RequestInterceptor;
import feign.RequestTemplate;
import lombok.extern.slf4j.Slf4j;
@Slf4j
public class HDTFeignInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate template) {
        // 这里可以对template做一些处理
        log.info("feign interceptor");
    }
}
```

1. 接口添加拦截器

```Java
import com.example.service.config.ProductFeignConfig;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.RequestMapping;

@FeignClient(name = "product", configuration = {HDTFeignInterceptor.class, ProductFeignConfig.class})
public interface ProductFeignService {
    @RequestMapping("/product")
    public String product();
}
```

### Nacos配置中心

nacos配置中心与springcloud config对比的优势：

- springcloud config大部分场景结合git使用，动态变更还需要依赖spring cloud bus消息总线来通过所有客户端的变化
- springcloud config不提供可视化界面
- nacos config使用长轮询更新配置，一旦配置变动后，通知provider的过程非常更快

sdf

1. 添加依赖

```Java
  <dependency>
      <groupId>com.alibaba.cloud</groupId>
      <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
  </dependency>
```

1. 需要用bootstrap.properties来配置nacos服务器地址

```Java
spring.application.name=product
spring.cloud.nacos.config.server_addr=127.0.0.1:8848
```

通过@Value来读取nacos config中的值是不能动态感知的，需要使用@Value注解所在的类添加@RefreshScope注解

### Sentinel——流控，降级

流控一般设置在服务提供端，降级一般设置到服务消费端

1. 添加依赖

```XML
<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-core</artifactId>
</dependency>
<!-- https://mvnrepository.com/artifact/com.alibaba.csp/sentinel-annotation-aspectj -->
<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-annotation-aspectj</artifactId>
    <version>1.8.3</version>
</dependency>
```

1. - 在代码中设置资源流控

```Java
// 被设置的资源，一般与访问接口同名
private static final String RESOURCE_SENTINEL = "sentinel";
@PostMapping("/sentinel")
public String sentinel() {
    Entry entry = null;
    try {
        entry = SphU.entry(RESOURCE_SENTINEL);

        String str = "hello world";
        System.out.println(str);
        return str;
    } catch (BlockException e) {
        log.info("block");
        return "被流控了";
    } catch (Exception e) {
        Tracer.traceEntry(e, entry);
    } finally {
        if(entry != null) {
            entry.exit();
        }
    }
    return "sentinel";
}

@PostConstruct
public static void initFlowRules() {
    // 流控规则集合
    List<FlowRule> rules = new ArrayList<>();
    // 设置流控规则
    FlowRule rule = new FlowRule();
    // 设置流控规则的资源
    rule.setResource(RESOURCE_SENTINEL);
    // 设置流控规则的模式
    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
    // 设置FLOW_GRADE_QPS下的数量，为1s一次
    rule.setCount(1);
    rules.add(rule);

    // 加载生效流控集合规则
    FlowRuleManager.loadRules(rules);
}
```

1. 第二步也可以通过注解来设置流控

```Java
    // 通过注解设置流控规则
    // 注：blockHandler 比fallback 优先级更高
    /**
     * 1.添加sentinel-annotation-aspect依赖
     * 2.添加配置bean-SentinelResourceAspect
     * 3.配置定制资源
     * 4.设置流控后的执行方法blockHandler(该方法需要public，而且返回值需要和原方法一致，参数也要一致，
     *     可以多加一个BlockException的参数,方法可以通过BlockException参数来判断是什么异常)
     * 5.blockHandler的方法需要在同一个类中，如果不在同一个类，则需要通过blockHandlerClass参数来指
     *     定方法所在类，此时blockHandler方法需要是静态方法
     * 6.fallback属性设置方法发生异常后执行的方法，(该方法需要public，而且返回值需要和原方法一致，参数也要一致，
     *     可以多加一个Throwable的参数,方法可以通过BlockException参数来判断是什么异常)
     * @return
     */
    private static final String RESOURCE_SENTINEL1 = "sentinel1";
    @SentinelResource(value = RESOURCE_SENTINEL1,blockHandler = "sentinelAfter", fallback = "exceptionHandler")
    @PostMapping("/sentinel1")
    public String sentinel1() {
        return "hello world";
    }

    public String sentinelAfter(BlockException be) {
        return "被流控了";
    }

    public String exceptionHandler(Throwable be) {
        return "exception";
    }
    
    // 需要往容器中注入Bean
    @Bean
    public SentinelResourceAspect sentinelResourceAspect() {
        return new SentinelResourceAspect();
    }
```

1. 降级设置

### Seata——分布式事务

分布式事务框架

### Gateway

- 断言 predicates
- 过滤器 filters
- 全局过滤器
- Reactor Netty访问日志
- 跨域配置
- 整合sentinel

### 自定义断言工厂

1. 必须是个bean组件
2. 约定大于配置，自定义类名必须是RoutePredicateFactory结尾
3. 必须继承AbstractRoutePredicateFactory
4. 必须在类中实现静态内部类，声明属性来接收配置文件中的配置信息
5. 需要结合shortcutFieldOrder方法来属性绑定
6. 通过apply进行逻辑判断，true就是匹配成功，false就是匹配失败

```Java
// 自定义断言类
public class HDTCheckRoutePredicateFactory extends AbstractRoutePredicateFactory<HDTCheckRoutePredicateFactory.Config> {
    public static final String PARAM_KEY = "param";
    public static final String REGEXP_KEY = "regexp";

    public HDTCheckRoutePredicateFactory() {
        super(HDTCheckRoutePredicateFactory.Config.class);
    }
    // 这个方法将HDTCheck断言后的第一个参数传入到config的name中
    public List<String> shortcutFieldOrder() {
        return Arrays.asList("name");
    }

    @Override
    public Predicate<ServerWebExchange> apply(Config config) {
        return new GatewayPredicate() {
            @Override
            public boolean test(ServerWebExchange serverWebExchange) {
                if(config.getName().equals("test")) {
                    return true;
                }
                return false;
            }
        };
    }
    // 定义属性，用于接受配置文件中的配置信息
    @Validated
    @Data
    public static class Config {
        private String name;
    }
}
```

配置断言，HDTCheck=test，满足上面断言类的配置则能访问， test1则不能访问

```YAML
spring:
  application:
    name: gateway
  cloud:
    gateway:
      routes:
        - id: product # 路由的唯一标识
#          uri: http://localhost:9091 # 使用域名配置需要转发的地址
          uri: lb://product # 使用nocas服务名配置需要转发的地址 , 需要导入loadbalancer依赖
          # 断言规则，路由规则匹配
          predicates:
            - Path=/product_uri/**  # 匹配路径
            - HDTCheck=test1  # 自定义断言规则，自定义断言类为HDTCheckRoutePredicateFactory
          filters:
            - StripPrefix=1 # 转发之前去掉第一个路径，比如上面会去掉product_uri
```

### Skywalking——链路追踪





## Nginx

nginx：隐藏参数

配置文件解读

```Bash
# 工作的worker进程个数，一般对应物理机的核数
worker_processes  1;

# 每一个进程能创建多少个连接
events {
    worker_connections  1024;
}

http {
    # 引入mime.types文件
    include       mime.types;
    default_type  application/octet-stream;

    # 类似于开启零拷贝，减少一次从磁盘读数据的过程
    sendfile        on;

    keepalive_timeout  65;

    # 一个server代表一个主机
    # 这个server 为本地主机的资源映射
    server {
        # listen       80;
        # 监听端口号
        listen       10001;
        # 可以配置域名或者主机名，也可以配置两个域名同时访问主机，也可以使用正则匹配
        # server_name localhost, localhost1
        # server_name *.localhost.com
        server_name  localhost;
        # 域名之后的uri
        location / {
            root   html;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }

    # 一个server代表一个主机
    # 这个server 为反向代理
    server {
        # listen       80;
        # 监听端口号
        listen       10002;
        # 可以配置域名或者主机名，也可以配置两个域名同时访问主机，也可以使用正则匹配
        # server_name localhost, localhost1
        # server_name *.localhost.com
        server_name  localhost;
        # 域名之后的uri
        location / {
            proxy_pass http://www.baidu.com
            root   html;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
    
    # 一个server代表一个主机
    # 这个server在反向代理的基础上添加upstream
    # upstream 的httphuangda为下面server的别名，默认会对upstream的服务器做轮询
    # weight为轮询的比例
    # down代表服务器下线 
    # backup指正常情况下该服务器不被使用，只有在其他服务器出故障的时候会被用到
    upstream httphuangda{
        server 192.168.1.23:80 weight=2 down;
        server 192.168.1.24:80 weight=8;
        server 192.168.1.25:80 weight=1 backup;
    }
    server {
        # listen       80;
        # 监听端口号
        listen       10003;
        # 可以配置域名或者主机名，也可以配置两个域名同时访问主机，也可以使用正则匹配
        # server_name localhost, localhost1
        # server_name *.localhost.com
        server_name  localhost;
        # 域名之后的uri
        # 单个 / 优先级最低
        location / {
            # 正则表达式，将1.html-9.html的url重写为/index.jsp?pageNum=?页面，
            # 其中$1代表前面第一个正则表达式的值
            # break是flag字段，表示匹配到了直接跳转，还有以下三个
            # last：匹配到了继续向下匹配
            # redirect：返回302重定向，浏览器会显示跳转后的地址
            # permanent：返回301永久重定向，浏览器会显示跳转后的地址
            rewrite ^/([0-9]+).html$  /index.jsp?pageNum=$1 break;
            proxy_pass http://www.baidu.com
        }
        # 这里会做拼接去访问/html/css文件夹
        location /css {
            root html;
            index index.html index.htm;
        }
        # 这里会做拼接去访问/html/img文件夹
        location /img {
            root html;
            index index.html index.htm;
        }
        # 上面两种也可以通过正则来配置
        # 
        location ~*/(css|img) {
            root html;
            index index.html index.htm;
        }
        # 配置错误码对应的错误页面
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
```

### Nginx动静分离——适用于中小型网站

防盗链属性 valid_references



## 设计模式

### 单例模式

```Java
// 懒汉模式
class LazySingleton {
    // 这里使用的是加volatile关键字，避免在创建singleton对象时的指令重排，
    // 导致返回的对象未初始化
    private volatile LazySingleton single = null;
    public LazySingleton() {}
    public LazySingleton getInstace() {
        if(single == null) {
            synchronized(LazySingleton.class) {
                if(single == null) {
                    single = new LazySingleton();
                }
            }
        }
        return single;
    }
}

//饿汉模式
class HungrySingleton {
    public static HungrySingleton singleton = new HungrySingleton();
    
    public HungrySingleton(){}
    
    public HungrySingleton getInstance() {
        return singleton;
    }
    
}
```

### 工厂模式

将对象实例化的过程推给子类实现

```Java
class Product extends Application{
    

}
```

### 建造者模式

Spring中RequestMappingInfo

### 原型模式 Prototype

复制对象，类实现Cloneable接口，重写clone方法，如果类成员属性有非基本类型数据（或基本类型包装类），则需要对其成员属性类实现Cloneable接口并重写clone方法

```Java
//使用重写clone方法，进行深拷贝
@Override
public Product clone() {
    Product clone = (Product) super.clone();
    //成员属性为muteable对象
    clone.setBaseInfo(baseinfo.clone());
    return clone;
}

//使用序列化进行深拷贝,属于CPU密集型任务
@Override
public Product clone() {
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
      ObjectOutputStream oos = new ObjectOutputStream(byteArrayOutputStream);
      oos.write(this);
      ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());

      ObjectInputStream ois = new ObjectInputStream(byteArrayInputStream);
      Product product = (Product) ois.readObject();
      return product;
}
```

### 享元模式

运用共享技术有效的支持大量细粒度的对象

JDK源码中应用，String，Integer，Long

### 门面模式

为子系统中的一组接口提供一个一致的接口，facade模式定义了一个高层接口，这个接口使得这一子系统更加容易被调用

Tomcat底层RequestFacade使用

### 适配器模式

将一个类的接口转化成客户希望的另一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的类能够一起工作

### 装饰者模式

在不改变原有对象的基础上，将功能附加到对象上

使用：

```Java
servlet.api下的
javax.servlet.http.HttpServletRequestWrapper
javax.servlet.http.HttpServletResponseWrapper
```

### 策略模式

## Netty

### 分散读取、集中写入

分散读取：channel.read(ByteBuffer[])传入多个buffer，每个buffer按顺序读取信息

集中写入：channel.write(ByteBuffer[])传入多个buffer，按照buffer顺序写入到文件

### 黏包、半包

发送多个数据包，服务端一次性接收到两个独立的数据包，两个包粘合在一起称为黏包

AB两个包，第一次读到了A包和部分B包，第二次读了B剩下的包称为半包

### FileChannel

只能工作在阻塞模式下

- 通过FileInputStream获取的channel只能读
- 通过FileOutputStream获取的channel只能写
- 通过RandomAccessFile是否能读写根据构造RandomAccessFile时的读写模式决定

Files.walkFileTree(Paths.get("E:\mail-ecnu"), new SimpleFileVisitor(){});

### 删除某个文件夹

```Java
Files.walkFileTree(Paths.get("E:\\mail-ecnu\\des"), new SimpleFileVisitor<Path>() {

    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
        Files.delete(file);
        return super.visitFile(file, attrs);
    }

    @Override
    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
        Files.delete(dir);
        return super.postVisitDirectory(dir, exc);
    }
});
```

### 复制文件夹

```Java
String source = "E:\\mail-ecnu\\source";
String target = "E:\\mail-ecnu\\target";
Files.walk(Paths.get(source)).forEach(path -> {
    try {
        String targetName = path.toString().replace(source, target);
        if (Files.isDirectory(path)) {
            Files.createDirectories(Paths.get(targetName));
        } else if(Files.isRegularFile(path)) {
            Files.copy(path, Paths.get(targetName));
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
});
```

![img](https://secure2.wostatic.cn/static/3vUeHMdhbBPJA7c5GBNu68/image.png)

同步阻塞、非同步阻塞、异步阻塞、异步非阻塞、多路复用、信号驱动

自定义协议要素

![img](https://secure2.wostatic.cn/static/g8Uj5KGhG3zQNARfKUHWPQ/image.png)

### ChannelFuture保证write操作在connect之后

channelFuture中的close，connect等都是在nio子线程中去执行，如果不特殊处理，无法保证后续操作在close和connect等之后顺序执行，因此一般采用sync阻塞，或者添加listener进行监听。

```Java
public void testChannelFuture() {
    ChannelFuture channelFuture = new Bootstrap()
            .group(new NioEventLoopGroup())
            .channel(NioSocketChannel.class)
            .handler(new ChannelInitializer<NioSocketChannel>() {
                @Override
                protected void initChannel(NioSocketChannel nioSocketChannel) throws Exception {
    
                }
            })
            .connect("locahost", 8080);
            
    //方法一：使用sync方法阻塞主线程，保证write等操作在connect操作之后
    // 这里的sync方法作用是阻塞主线程，由于connect动作是nio线程去做的，因此需要阻塞保证connect动作完成
    // 如果没有sync方法，那么无阻塞的情况下无法保证下面的write等操作在connect之后
    channelFuture.sync();
    Channel channel = channelFuture.channel();
    channel.writeAndFlush("ye");
    
    //方法二：使用addListener异步处理
    //在connect完成之后才执行write等后续操作
    channelFuture.addListener(new ChannelFutureListener() {
        @Override
        public void operationComplete(ChannelFuture channelFuture) throws Exception {
            Channel channel = channelFuture.channel();
            channel.writeAndFlush("ye");
        }
    });
}

public void testcloseChannelFuture() {
    NioEventLoopGroup nioEventLoopGroup = new NioEventLoopGroup();
    ChannelFuture channelFuture = new Bootstrap()
            .group(new NioEventLoopGroup())
            .channel(NioSocketChannel.class)
            .handler(new ChannelInitializer<NioSocketChannel>() {
                @Override
                protected void initChannel(NioSocketChannel nioSocketChannel) throws Exception {
    
                }
            })
            .connect("locahost", 8080);
            
    channelFuture.sync();
    Channel channel = channelFuture.channel();
    channel.writeAndFlush("ye");
    //关闭channel，需要获取closeFuture，然后使用sync同步close动作完成，或添加监听器
    ChannelFuture closeChannel = channel.closeFuture();
    closeChannel.sync();
    closeChannel.addListener(new ChannelFutureListener() {
        @Override
        public void operationComplete(ChannelFuture channelFuture) throws Exception {
            nioEventLoopGroup.shutdownGracefully();
        }
    });
}
```

处理黏包半包：LengthFieldBasedFrameDecoder()

可使用EmbeddedChannel临时搭建channel测试

```Java
//设置连接超时5000ms
bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLS,5000)
//设置accept等阻塞操作超时5000ms
bootstrap.option(ChannelOption.SO_TIMEOUT,5000)
```



## Javaweb

### Servlet生命周期

加载类——> 实例化——> 初始化——>请求处理——>销毁

web.xml中配置load-on-startup=0时，则第一次请求时则执行init方法创建一个servlet对象，该servlet对象处理所有的客户端请求，service中执行，最后服务器关闭，销毁这个servlet对象。而load-on-startup=1则在服务器启动时创建servlet

### forward()和redirect()的区别

- forward是服务器直接访问目标地址然后返回给客户端，数据可共享，一次请求，比如登陆后进行forward到新页面
- redirect是服务器告诉客户端重新请求一个新地址，数据不可共享，两次请求，比如用户注销，或转跳到其他网站

### getAttribute()和getParameter()的区别

getParameter：返回字符串、获取的是客户端的的数据、获取request中的参数值

getAttribute：可以返回任意类型、获取的是服务器设置的数据、数据会保存在页面内存，重定向其他页面这个数据也会同步

| HTTP1.0      | HTTP1.1      | HTTP1.2                           |
| ------------ | ------------ | --------------------------------- |
| 短连接       | 长连接       | 可以直接在一个tcp连接并发发送请求 |
| 基于文本即系 |              |                                   |
| 明文传输     |              |                                   |
|              | 加了host字段 |                                   |
|              | 新增状态码   |                                   |
|              |              |                                   |

### Get与POST的区别

GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面：

(1). 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；

(2). 从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；

(3). 从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体 中。

(4). 就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。

(5). 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。

### Cookies和Session

http是无状态的协议，cookies被用来保存一些站点的用户数据，这就能够让服务器识别到用户身份，进行定制化的处理请求。当客户端访问服务端后，服务端会生成一份cookies传给客户端，客户端会将cookies保存起来，之后每次访问服务端的时候都会自动携带这个cookies。

session是另一种记录客户状态的机制，session是保存在服务端，客户端访问服务端的时候，服务端把客户端信息以某种形式记录在服务器上。客户端再次访问的时候只需要从session中查找该用户状态。

两个都是用来跟踪客户端用户身份的会话方式。

cookies特点：保存在客户端容易被篡改、保存的数据量有限

session特点：保存在服务器端，更加安全，访问增多时会增加服务端压力

### Filter和Interceptor的执行节点

![img](https://secure2.wostatic.cn/static/c3NRgstAWSZeYLgkAJYffh/image.png)

### JDBC访问数据库的步骤

- 注册驱动：class.forName("com.msql.jdbc.Driver")
- 获取连接：DriverManager.getConnection(url, user, pw);
- 创建statement语句对象
- 执行sql语句
- 处理结果集
- 关闭资源

### 请求头结构

```ybsz
GET /HTTP/1.1
HOST: http://www.baidu.com
Content-Type:text/html

请求体
```

| 字段名            | 说明                                                         | 示例                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Accept            | 能够接受的回应内容类型（Content-Types）                      | Accept: text/plain                                           |
| Accept-Charset    | 能够接受的字符集                                             | Accept-Charset: utf-8                                        |
| Accept-Encoding   | 能够接受的编码方式列表                                       | Accept-Encoding: gzip, deflate                               |
| Accept-Language   | 能够接受的回应内容的自然语言列表                             | Accept-Language: en-US                                       |
| Authorization     | 用于超文本传输协议的认证的认证信息                           | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==            |
| Cache-Control     | 用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令 | Cache-Control: no-cache                                      |
| Connection        | 该浏览器想要优先使用的连接类型                               | Connection: keep-alive Connection: Upgrade                   |
| Cookie            | 服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie | Cookie: $Version=1; Skin=new;                                |
| Content-Length    | 以 八位字节数组 （8位的字节）表示的请求体的长度              | Content-Length: 348                                          |
| Content-Type      | 请求体的 多媒体类型                                          | Content-Type: application/x-www-form-urlencoded              |
| Date              | 发送该消息的日期和时间                                       | Date: Tue, 15 Nov 1994 08:12:31 GMT                          |
| Expect            | 表明客户端要求服务器做出特定的行为                           | Expect: 100-continue                                         |
| Host              | 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号 | Host: [en.wikipedia.org:80](http://en.wikipedia.org:80) Host: [en.wikipedia.org](http://en.wikipedia.org) |
| If-Match          | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源 | If-Match: "737060cd8c284d8af7ad3082f209582d"                 |
| If-Modified-Since | 允许在对应的内容未被修改的情况下返回304未修改                | If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT             |
| If-None-Match     | 允许在对应的内容未被修改的情况下返回304未修改                | If-None-Match: "737060cd8c284d8af7ad3082f209582d"            |
| If-Range          | 如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体 | If-Range: "737060cd8c284d8af7ad3082f209582d"                 |
| Range             | 仅请求某个实体的一部分                                       | Range: bytes=500-999                                         |
| User-Agent        | 浏览器的浏览器身份标识字符串                                 | User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 |
| Origin            | 发起一个针对 跨来源资源共享 的请求                           | Origin: http://www.example-social-network.com                |

## RocketMQ

问题：

怎样保证消息创建的有序性

怎样指定创建Queue的数量

一个消息只能对应一个topic

一个生产者可以对应多个topic，一个topic只能对应一个消费者，；

**队列**：存储消息的物理实体。一个topic中可以包含多个队列，每个queue中存放的就是该topic的消息，一个topic 的queue也被称为消息中的分区（partition）。而一个分区中只能对应一个消费者，多个分区可以对应多个消费者。

**注意**：一个消费者只能一个Topic中的分区，只能被一个消费者组中的一个消费者消费。一个Topic中的分区不允许一个消费者组中的多个消费者同时消费

- 一个组中的消费者必须订阅完全相同的topic，这样可以很好的实现负载均衡
- 消费者组只能消费一个topic，不能同时消费多个topic消息

### NameServer

NameServer以集群的方式部署，但他们之间是没有通信的，在Broker启动的时候会轮询NameServer列表，与其建立长连接，发起注册请求。而NameServer中维护着一个Broker列表，正因为集群之间没有通信，所以对于Broker，必须明确指出所有的NameServer地址，不能随便对集群进行扩容，每次扩容后，Broker并不会对新增加的这个NameServer进行注册。为了证明自己是活着的，broker每30s会发送心跳包。

**路由剔除**：每隔10s扫描一次Broker表，查看每一个Broker的存活时间是否超过120s，超过就判定无效将其从Broker表中删除。

**路由发现**：客户端每30s拉取一次最新路由

> pull      模型：拉取模型，定时拉取数据，实时性较差； push    模型：推送模型，实时性好，需要维护长连接，浪费资源；适用于client少 long Polling模型：长轮询模型；

### 客户端NameServer选择策略（客户端指producer，consumer）

首先从nameserver中随机取，如果选择失败，则采用轮询

### Broker

手动创建Topic的两种模式

自动创建Topic：

### rocketMQ安装

- 搭建好多机环境，启动设备，下载rocketmq包，并解压
- 如果内存不够可以修改目录下bin/runserver.sh、runbroker.sh文件中的JAVA_OPT变量中的-server -Xms和-Xmx设置内存大小
- 启动nameserver

```Bash
#启动mqnamesrv
nohup sh bin/mqnamesrv &
#可查看日志是否成功启动，也可以通过jps查看java进程
tail -f ~/logs/rocketmqlogs/namesrv.log
```

- 启动broker

```Bash
#启动mqbroker
nohup sh bin/mqbroker -n localhost:9876 &
#可查看日志是否成功启动，也可以通过jps查看java进程
tail -f ~/logs/rocketmqlogs/broker.log
```

- 配置nameserver地址

```Bash
export NAMESRV_ADDR=localhost:9876

#生产消息
sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer
#消费消息
sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer
```

- 关闭server

```Bash
sh bin/mqshutdown broker
sh bin/mqshutdown namesrv
```

broker集群**复制策略**（指从master复制到slaver）：同步复制（master刷盘成功，slave刷盘成功返回成功），异步复制（master刷盘成功返回成功，slave刷盘）

**刷盘策略**（指从broker的内存写入到磁盘）：

- 同步刷盘（消息写到broker内存后持久化到磁盘返回成功）

- 异步刷盘（消息写到broker内存返回成功，后持久化到磁盘）

  > 1）异步刷盘策略会降低系统的写入延迟，RT变小，提高了系统吞吐量 2）消息写入到内存，一般是写入到PageCache 3）对于异步刷盘策略，消息自动写入到PageCache后立即返回成功ACK。但不会立即做落盘操作，而是当PageCache到达一定量时会自动进行落盘

broker集群模式：单master、多master、多master多slaver-异步复制、多master多slaver-同步双写

### 分布式事务XA模式架构

### RocketMQ的工作原理

#### 一、消息生产

- Producer发送消息之前先向NameServer发出获取消息Topic的路由信息请求
- NameServer返回该Topic的路由表及Broker列表
- Producer根据代码指定的Queue选择策略，从Queue列表中选出一个队列，用于后续存储消息
- Producer对消息做一些特殊处理
- Producer向选择出的Queue所在的Broker发出RPC请求，将消息发送到选择出的Queue

#### Queue选择算法

轮询算法：有的broker上的queue投递延迟很大，这可能会导致producer上的消息出现积压

最小投递延迟算法：记录每次投递的投递延迟，往投递延迟最小的broker上发消息，可能会导致broker消息过多queue上的消息分配不均匀，降低了消费能力

#### 消息的存储

- rocketmq的消息存储在本地文件系统中，
- checkpoint：存放commitlog、consumequeue、index文件的最后刷盘时间戳
- commitlog：存放commitlog文件（也叫mappedFile文件），消息写在里面，单个文件小于等于1G，文件名由20位十进制数字组成，代表了当前文件的第一条消息的起始位偏移量。一个broker包含一个commitlog目录，其中的消息是顺序写入。每个消息都是一个消息单元，由消息总长度msgLen、消息的物理位置physicalOffset、消息体中的内容Body、消息体长度BodyLength、消息主题Topic、Topic长度TopicLength、消息生产者BornHost、消息发送时间戳BornTimestamp、消息所在队列QueueId、在Queue中存储到位偏移量
- config：存放broker运行需要的配置数据
- consumequeue：存放consumequeue文件，队列放在这里；
- index：其中放着消息索引文件indexFile
- lock：运行期间使用到的所有全局锁

#### 消息的消费

#### 消费模式

- 广播消费：相同的consumer group的每个consumer都会收到同一个topic的全量消息；消息进度保存在consumer端
- 集群消费：相同的consumer group的每个consumer均摊同一个topic的全量消息；消费进度需要共享所以保存在broker中。

#### Rebalance机制

将一个Topic下的多个Queue在同一个Consumer Group中的多个consumer间重新分配的过程。

#### Queue分配算法

平均分配策略：

环形平均策略：

一致性hash策略：

同机房策略：

### Rocket应用场景

**应用解耦**

**流量削峰**

**数据分发**

**异步处理**

**日志处理**

**RocketMQ的优势**：吞吐量高、可用性高、消息可靠性高、稳定性高、支持消息堆积

先启动NameServer集群，NameServer之间无数据交互，Broker启动后每30s向NameServer发送心跳包（包括IP、Port、TopicInfo），如果broker超过120秒没有发送，则将其下线，移除相关信息。

Producer上线后每30s从NameServer中获取Topic和Broker的映射关系，并存在本地，发现新的broker，就会与其建立长连接，每30s发送心跳至broker维护连接

包括四部分：

- **NameServer集群（Broker管理、路由信息管理）**：担任路由消息的提供者，生产者和消费者能通过NameServer查找各个Topic相应的Broker IP列表分别进行发送消息和消费消息。NameServer由多个无状态节点构成，节点之间无任何信息同步。
- **Producer集群**：负责生产消息，消息生产者会将业务应用系统产生的消息发送到broker服务器。发送方式有， 同步发送、异步发送、顺序发送、单向发送。同步和异步均需要broker返回确认信息，单向发送不需要。
- **Consumer集群**：负责消费消息，消息消费者从broker服务器拉取消息，并将其提供给应用程序。
- **Broker集群**：接受从生产者发送来的消息并存储、同时为消费者的拉取请求做准备。

![img](C:%5CUsers%5Chdt%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220331204928392.png)

#### Rocket部署类型

- 单Master
- 多Master
- 多Master多Slaver，异步复制
- 多Master多Slaver，同步双写

#### Broker选择算法

#### 如何保证RocketMQ的高可用

- 集群化部署NameServer：Broker会将所有的broker基本信息，topic信息以及两者的映射关系，轮询存储在每个NameServer中。因此NameServer的集群化，不会因为某几个服务器挂掉影响整个架构的功能
- 集群化部署Broker
- 设置同步复制

#### RocketMQ的工作流程

- 启动NameServer，启动后监听端口，等待Broker、Producer以及Consumer连接
- 启动Broker，启动之后会和所有的NameServer保持一个长连接
- 创建Topic，创建时需要指定该Topic存储在哪些Broker上
- Producer发送消息
- Consumer消费消息

#### RocketMQ采用那种方式消费，pull还是push

提供pull和push两种消费方式，但实质上都是采用consumer轮询从broker中拉取消息

push方式里，consumer将轮询过程封装了一层，并注册了消息监听器。当轮询取到消息后，便唤醒消息监听器来消费，对用户而言就感觉像是被推送过来的

#### RocketMQ怎样负载均衡

- producer发送消息负载均衡：默认轮询向Topic的所有queue发送消息，以达到消息平均落到不同的queue上，落到不同的queue上也就发到了不同的broker上
- consumer订阅消息负载均衡：一般多个消费者的时候会平均分队列，为了避免浪费，所以一般consumer数量小于队列数量

#### RocketMq的存储机制

传统方式实现是先读取、在发送，实际会经过四个复制：

- 读取磁盘文件到系统的内核缓冲区ReadBuffer
- 将内核缓冲区的数据复制到应用程序的Application Buffer
- 将Application Buffer的数据复制到Socket网络发送缓冲区
- 将socket buffer的数据复制到网卡，由网卡进行网络传输

采用文件系统进行消息的存储，使用顺序写和零拷贝。

- 顺序写：对消息在磁盘上的采用顺序写，直接将数据追加到末尾。
- 零拷贝：直接从磁盘读取文件数据到内核缓冲区，然后直接复制到网卡发送。避免了传统方式的四个步骤

小知识：零拷贝技术采用的是MappedByteBuffer内存映射技术，限制了传输的文件不能超过2G，因此存储消息文件CommitLog的大小规定为1G

#### RocketMq的存储结构

消息生产者将消息发送到broker，按照顺序存储到CommitedLog文件中，每个文件不超过1G

CommitLog存储所有的消息源数据，包括Topic、QueueId以及Message

#### Topic

是一类数据的集合，可分布式存储

#### RocketMq如何消息去重

- 建立日志表，消息主键作为表的主键避免消息重复消费

#### RocketMq性能高的原因

采用文件系统存储消息，采用顺序写方式写入消息，使用零拷贝

#### RocketMq怎样处理顺序消费、重复消费、消息丢失、消息传递有序性、消息堆积

顺序消费：同一组顺序消息发送到一个broker下的同一个队列，消费者顺序执行

重复消费：消费端保证业务逻辑保持幂等、每条消息都有一个唯一编号处理成功与日志同时出现

消息堆积：

消息丢失：

- 首先生产者发送half消息到RocketMQ中，此时消费者是无法消费half消息的，若half消息就发送失败了，则执行相应的回滚逻辑
- half消息发送成功之后，且RocketMQ返回成功响应，则执行生产者的核心链路
- 如果生产者自己的核心链路执行失败，则回滚，并通知RocketMQ删除half消息
- 如果生产者的核心链路执行成功，则通知RocketMQ commit half消息，让消费者可以消费这条数据

Consumer与NameServer的一个节点建立长连接，定期从NameServer中获取Topic路由信息，并向提供Topic服务的Master、Slaver建立长连接，定时向master、slave发送心跳。

Consumer每隔30秒向所有关联的broker发送心跳，

## Java基础

### 类的执行顺序？

字节码解析会将 1、2、3、4按照执行顺序整合成一个方法，执行顺序按照其先后顺序，因此先执行b=60,后执行b=70

```Java
public class Demo{
    public int a = 10;  // 1
    {
        b = 60;        // 2
    }
    
    public int b = 50;  //3 
    { 
        a = 20;         // 4
    }
    
    {
        b = 70;           // 6
    }
    
    public Demo() {  7
        a = 30;
        b = 80;
    }
}
```

### 什么时候会触发类加载？

- new新对象
- 访问类的静态属性，静态方法
- 通过反射创建对象，初始化类

### 快表

### HashMap

构造的时候不会初始化空间，在put的时候发现为空，则创建初始容量16

主干是Entry数组，每个Entry包含一个key-value键值对

```Java
/**
默认长度为 1 << 4   16
碰撞因子  0.75
最大长度 1 << 30   2^30， 新建传入的容量大于这个容量的时候会不超过这个值
Node实现了Map.Entry接口
*/
```

#### 为什么扩容是两倍扩容

这是因为计算元素在数组中的地址的时候是(n  - 1) & hascode ，这种情况下n - 1的二进制全是1，与的结果为hascode的后几位，减少hash碰撞

10001

### HashMap1.7和1.8的区别

- 7用的是头插法，8用的是尾插法；使用头插法在多线程扩容时出现循环和逆序
- 7用的是数组加链表，8用的是数组加红黑树

### ConcurrentHashMap1.7和1.8的区别

- 7基于Segment+HashEntry实现；8数据结构为Node+红黑树，基于Synchronized+CAS+红黑树实现，锁粒度缩小为节点锁
- 7需要两次定位，先到对应的segment，然后到对应的数组位置，对segment加锁插入；8直接定位到对应位置，如果当前位置没有元素则CAS插入，如果有元素则使用synchronized插入。
- 7计算size采用乐观锁机制计算，先不加锁统计最多三次，如果前后两次size一致则返回size，超过三次则直接对每个segment加锁然后计算size；8维护一个baseCount属性用来记录节点数量，每次put都会CAS自增baseCount
- 7的get方法

**HashMap转成红黑树的条件**：链表长度大于8，且数组元素大于64个

#### HashMap扩容的时候链表和红黑树怎么处理

链表拆分：链表拆分的时候通过和原容量oldCap(一般是2^n)进行与位运算，如果最高位是1那么他的新索引是原索引+原容量，最高位是0那么还是原索引，就这样被拆分成了两部分

红黑树拆分：也是先拆成两部分，然后看要不要转成红黑树

#### 为什么选择红黑树，而不是AVL二叉树

- AVL是严格的平衡二叉树，因此可以提供更快的查找速度，一般适合读取查找密集型任务
- 红黑树适合于插入修改密集型任务
- AVL的旋转比红黑树的旋转更难以平衡，AVL平衡的高低差最多是1，而红黑树能达到两倍，不是严格的平衡。AVL可能需要O(log n)此平衡，但是红黑树最多需要两次旋转

#### ConcurrentHashMap

put数据的时候，

- 如果当前位置没有数据则使用cas操作往里面赋值
- 如果当前位置不为空，且有线程在扩容，则帮忙一起扩容
- 如果当前位置不为空，当前为链表结构 插入时对节点node加锁，比1.7的segment更细粒度
- 如果当前位置不为空，当前为树结构 插入时对节点node加锁，尾插法

#### CopyOnWriteArrayList

### Java的异常体系

- 所有的异常类都来自顶级异常父类Throwable
- Throwable有两个子类，Error和Exception
- Error指的是报错，无法处理，程序将停止运行
- Exception是异常不会导致程序停止，分为RuntimeException和CheckedPointException
- RunTimeException会导致当前线程终止
- CheckedPointException一般是编译时失败

### 守护线程

为所有非守护线程提供服务线程，比如垃圾回收线程

### ArrayList和Vector的区别

两个底层都是数组实现的

- ArrayList是线程不安全的，每次扩容默认为原来的两倍
- Vector用synchronized加锁，是线程安全的，默认扩容增加原来的一半

### 线程池

任务到达，如果核心线程数未满，则直接创建新线程执行任务，如果满了，则将其放入等待队列

如果等待队列未满，则将其放入等待队列，如果满了，则看是否超过最大线程数，如果不超过则创建新线程执行，如果超过则执行饱和策略。

之所以在核心线程数满了之后先往阻塞队列中放，是因为创建新线程需要获取全局锁，会阻塞其他线程，影响效率，因此只有在队列满了，十分繁忙的时候才去创建。

工作流程如下：

![image-20220718140609932](asset/image-20220718140609932.png)

#### 线程池复用原理

线程池将任务和线程解耦，普通创建线程是Thread.start来执行，线程池线程是通过内部执行循环来判断是否有任务执行，若有就执行（调用run），如果没有就继续循环。



#### Executors.newSingleThreadPool

单个线程池，串行执行任务

#### Executors.newFixedThreadPool

固定数量线程，满了就阻塞

#### Executors.newCacheThreadPool

缓存线程池，60s没有执行就回收空闲，有任务新增线程

#### Executors.newScheduleThreadPool

大小无限制的线程池，支持定时和周期性的执行线程

Executors返回的线程池弊端如下，因此尽量使用ThreadPoolExecutor自定义：

1、FixedThreadPool和SingleThreadPool：底层用LinkedBlockingQueue长度为Integer.MAX_VALUE;可能导致OOM

2、CachedThreadPool和ScheduleThreadPool允许创建的长度为Integer.MAX_VALUE，可能导致OOM

初始化线程池时

ThreadPoolExecutor继承AbstractExecutorService抽象类

AbstractExecutorService继承ExecutorService接口

ExecutorService继承了Executor接口

通过

```Java
// 创建单例线程池，当繁忙时，多余线程会进入阻塞队列等待，保证任务按序按优先级执行，使用LinkedBlockingQueue
Executors.newSingleThreadExecutor();

// 创建固定长度为3的线程池，每个线程的存活时间是无限的，满了之后新任务进入无界的阻塞队列等待，适用于执行长期任务，LinkedBlockingQueue 
Executors.newFixedThreadPool(3);

// 创建ScheduledThreadPool线程池对象，线程内线程存活时间无限制，可以支持定时及周期性任务执行。如果所有线程处于繁忙状态，新任务会进入DelayWorkQueue队列中，按超时时间排序的队列结构，SynchronousQueue，一般只有消费者和生产者同时存在的时候才会成功，不然就一直阻塞
Executors.newScheduledThreadPool();

// 返回ThreadPoolExecutor实例，创建一个可缓存的线程池，如果线程池大小超过任务所需，那么就会回收空闲线程（60秒不执行任务），不对线程池大小做限制。适用于执行很多短期的异步任务，BlockingQueue
Executors.newCachedThreadPool();
```

submit方法有Future类型的返回，而executor没有

#### 阻塞队列：

```Java
ArrayBlockingQueue：数组有界阻塞队列，先进先出
LinkedBlockingQueue：链表有界阻塞队列，
PriorityBlockingQueue：优先级排序无界阻塞队列
DelayQueue：优先级队列实现的无界阻塞队列
SynchronousQueue：不存储元素的队列
LinkedTransferQueue：链表无界阻塞队列
LinkedBlockingQueue：
```

#### ThreadLocal

ThreadLocal，即线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。

多线程访问同一个共享变量的时候容易出现并发问题，特别是多个线程对一个变量进行写入的时候，为了保证线程安全，一般使用者在访问共享变量的时候进行额外的同步措施才能保证线程的安全性，ThreadLocal是除了加锁这种同步方式外的一种保证规避多线程访问出现线程不安全的方法，每个线程在访问的时候都是线程自己的变量就不会存在线程安全。

Thread中有两个变量threadLocals和inheritableThreadLocals，两个都是ThreadLocal内部里诶ThreadLocalMap类型变量，类似于是一个hashMap，只有在线程第一次调用ThreadLocal的set或get方法的时候才会创建他们。ThreadLocal类型的本地变量是存放在具体的线程空间上

子类的inheritableThreadLocals属性可以继承父进程的inheritableThreadLocals属性

#### 什么是FutureTask

FutureTask表示一个可以取消的异步运算。有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候才能取回结果，如果运算尚未完成get()方法会将其阻塞。

在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行

### 线程安全的集合类

ConcurrentHashMap

CopyOnWriteArrayList

CopyOnWriteArraySet

### JDK1.8的新特性

- 接口里面可以带默认实现，要加上default关键字
- lambda表达式
- stream流
- 函数式编程

### 二叉搜索树和平衡二叉树的区别

二叉搜索树，所有左边的节点都比右边的节点小

平衡二叉搜索树除了满足左边的节点都比右边的节点小，还需要满足节点左右子树高度差不得超过1

### 平衡二叉树和红黑树的区别

- AVL树比红黑树平衡更严格，一般AVL树的高度更低
- 红黑树加入节点颜色概念
- AVL树旋转操作比红黑树操作更耗时

### select、poll、epoll的区别

- select使用数组存储socket连接文件描述符，容量固定，需要通过轮询来判断是否发生了IO事件，复杂度O(n)
- poll使用链表存储socket连接文件描述符，容量不固定，需要通过轮询来判断是否发生了IO事件，复杂度O(n)
- epoll是一种时间通知类型，发生了IO事件，才进行处理，不需要主动IO轮询，复杂度为O(1)



### 设计模式



## Redis

#### 缓存类型有哪些？

本地缓存：本地线程内进行缓存，受限于单机容量

分布式缓存：满足大容量的数据缓存，但需要远程请求，性能不如本地缓存

多级缓存：最热点的数据放在本地缓存，其他数据放在分布式缓存

#### 有哪些缓存淘汰策略？

allkeys-lru：对所有的键使用最近未被使用策略

volatile-lru：在设置了过期时间的key使用最近未被使用策略

allkeys-random：对所有的键使用随机策略

volatile-random：对设置了过期时间的使用随机策略

volatile-ttl：在设置了过期时间的键，删除更早过期的键

FIFO、LRU、LFU

LinkedHashMap使用了LRU算法

#### Redis有哪些数据类型？

**String**：set、get来操作。

应用场景：

- 缓存功能：支持高并发，可以用来做缓存
- 计数器：快速实现技术和查询功能
- 共享用户session：保证redis的高可用基础下，便能实现共享session

**Hash**：类似Map，可以将结构化数据缓存在redis中。

**List**：有序列表，可存储列表型数据，使用lrange可实现高性能的分页查询。也可以做个简单的消息队列

**Set**：无序集合，自动去重

**Sorted Set**：有序集合。写入的时候加个分数，根据分数排序

**Bitmap**：按bit来存储信息可以用来实现布隆过滤器

**Geospatial**：用来保存地理位置，根据位置来计算距离，实现附近的人

**pub/sub**：订阅发布功能，用作简单的消息队列

**Pipeline**：批量执行一批指令，一次性返回全部结果，不具备原子性，可以理解为将多个命令打包一次执行，命令之间无顺序关系，这个命令不能保证原子性的原因是在实际传输的时候，并不能保证一个pipeline能够在同一个包里面被执行。他是先将pipeline的数据写入socket的内核缓冲区，内核会根据当前的网络状况的将其发送到服务端》

**Lua**：可以用这个来执行一次性操作，实现简单的原子性，命令之间有依赖关系，一个请求多个命令，减少网络开销

#### Redis事务

Watch指令：内部用的是CAS锁，属于乐观锁

redis事务不是严格的事务，只保证串行操作，不保证事务回滚

事务执行开始

- MULTI事务开始
- 命令入队
- 事务执行EXEC

分布式系统中的一次业务可能需要多个应用来实现，比如用户发送一次请求可能涉及到订单系统的创建，库存系统、订单等，这种情况下用到的分布式事务，用到的系统有：

- 本地消息表：哪个系统调用失败，系统后台则直接重试
- 消息队列：消息中间件，

#### Redis持久化

**AOF**：以日志的方式记录数据操作追加到文件，fork一个子进程用来不停地往二进制压缩文件中写记录，这样做的话QPS会比RDB低很多

**RDB**：将整个数据库的数据保存到本地，固定时间进行保存，因此如果系统宕机容易丢失上次保存到当前时间的数据

#### Redis高可用

设置主从同步，通过sentinel来监控redis的服务状态，当master挂掉，就从其他的slaver选一个出来作为master。并将其他的slaver更新到新主。

哨兵必须用三个实例来保证自己的高可用，但是无法保证数据的强一致性。

哨兵组件：集群监控、消息通知、故障转移、配置中心

当第一次slaver连接到master后，会发送一个psync命令给master，如果这个slave第一次连接到master那么，他会出发一个全量复制，master会启动一个线程生成RDB，而且把这期间的数据缓存到内存中，RDB文件生成后，将其发送到slave，然后再把自己缓存里的命令也发送给slave。后续就直接用AOF的方式发送到slave了。

#### Redis key失效机制

缓存更新机制：先更新DB，后刷新缓存。缓存时间失效

数据不一致：如果数据库更新后，Redis更新失败。如果服务对耗时不是特别敏感，可以添加重试；如果耗时敏感的话，可以通过异步补偿任务来处理失败的更新。如果短期的数据不影响业务，那么只要下次更新成功就行，最终能保证一致性即可。

**缓存穿透**：用不存在的数据进行访问，导致请求落到了数据库。

- 对不存在的用户缓存null值，但是可能导致大量的无用缓存数据
- 使用布隆过滤器，快速判断是否存在于数据库中，使用bitmap来实现。

**缓存击穿**：某个热点数据失效，大量请求落到数据库，（从数据库中读数据加锁，然后保证后面的大量请求都能从redis中读取）

- 使用互斥锁进行更新。
- 针对多个热点数据设置随机失效时间
- 随机避退方式，失效时设置一个很短的sleep时间再次查询，如果失败再执行更新

**缓存雪崩**：缓存挂掉，所有请求落到数据库，设置随机时间，加集群部署；或者大面积key失效

- 使用快速失败熔断机制
- 使用主从模式来保证redis的高可用

#### Redis为什么那么快？

- 完全基于内存，大部分请求都是纯粹的内存操作，数据以key-value模式存储，查找和操作的时间复杂度都是O(1)级别的
- 数据结构简单，有List、String、Set、Hash、Sorted Set
- 采用单线程，避免了不必要的上下文切换，也没有多线程竞争
- 采用多路复用IO，非阻塞IO
- 底层模型不同，Redis直接自己构建了VM

Set、Link、SortedSet、Hash

### Redis是单线程还是多线程

Redis在进行事件处理时是单线程，使用多路IO复用，处理文件，磁盘读写等耗时操作是多线程

#### Redis内存用完了之后会发生什么？

Redis写命令会返回错误，如果配置了内存淘汰机制，那么会根据策略淘汰掉内存，比如LRU、LFU。

#### Redis的Hash

#### Redis在集群模式下，key是如何寻址的？

- 通过哈希的方式将数据分片，每个节点均匀分到一定的哈希槽，默认分配了16384个槽位
- 默认端口是6379，而16379端口是用来和slaver进行通信的

#### 分布式问题

通过setnx命令来设置锁，

#### Redis数据缓存一致性

1、先删除缓存，后更新数据，存在问题是，删除了缓存，后台未更新这段时间可能读到的是旧数据

解决方案：

- 延时双删：在缓存中读不到数据，sleep一段时间，保证这段时间内数据库数据会被刷新。

2、先更新数据库，再删除缓存，如果缓存删除失败，或来不及删除还是会读到旧值

解决方案：

- 消息队列：先更新数据库，成功后往消息队列里发消息，消费消息后再删除缓存，借助消息队列的重试机制来实现，达到最终一致性效果。但还是存在问题，比如怎么保证消息不丢失，消息有延迟性

进阶版方案：借助binlog来解决这个问题



### 分布式id

- UUID：结合时间戳、时钟序列、机器识别号生成，缺点是不是有序的，是字符串，过长，id可读性差
- 数据库自增主键：每次读写都必须访问数据库，压力大，而且有从数据库的话，还需要同步
- leaf-segment（美团）：通过区间来获取id，当获取的id用完后再去获取；可能多个节点同时申请id区间，需要依赖DB
- 雪花算法



#### 分布式锁

基于数据库实现

使用过期键，基于redis实现

#### Redis的存储结构

Redis内部使用SDS作为存储结构，一个SDS值的数据结构如下，并且字符串结尾用`\0`结尾：

```c
struct sdshdr{
    int free;	// buf未使用的长度
    int len;	// buf中保存的字符串的长度
    char buf[];	// 保存字符串的数组
}
```

优点：

- 效率高：使用STRLEN求字符串长度时，可直接通过返回`len`获得，不用像c中挨个遍历获得
- 防止数据溢出：c不记录字符串长度，用这种方法可以避免溢出
- 空间预分配：可通过free来检查空间是否满足
- 惰性空间释放：使用free记录空闲，满足条件情况下可以直接扩展

#### 为什么MySQL使用B+树不使用跳表作为索引？



- B+树更稳定：跳表使用二路分治，B+树使用多路分治，复杂度都是log n，但当数据足够多的时候，B+树到每个节点的路径长度是均匀的，这样更加稳定。跳表随着查询值越大跳表路径越深，磁盘IO次数越多

- 



















## 练习

redis数据库数据一致性

springboot 的启动流程

CountDownLatch

springboot用到了哪些设计模式

spring Actuator

Redis集群

RPC原理

spring security

spring aop的拦截器链的基本执行流程

spring解决跨域问题

spring日志配置

spring事件

mybatis插件原理

设计模式

- 单例
- 抽象工厂
- 观察者
- 装饰
- 

springsession

sentinel

分布式session

正则表达式

AQS、锁升级

interception filter的调用流程

哨兵模式

代理对象生成

lazy

aop实现：https://www.bilibili.com/video/BV1P44y1N7QG?spm_id_from=333.337.search-card.all.click&vd_source=19e28d4fb79c418a82532be14b1b0bc3

spring  事务

try catch中的return看jvm视频

stream流

ThreadLocal

rocketmq的半事务，事务处理    ，自己的producer发送消息后，consumer不能立即收到信息

protected

dubbo的模拟代码，周瑜   这可能是B站讲得最好的Dubbo教程完整版全集

xml中的xsd和dtd

Swagger

shiro

hashmap1.7和1.8的区别

concurrenthashmap 的区别

apifox

读写分离 shareding-jdbc

springcache+redis瑞吉外卖

JDK的spi和dubbo的SPI区别

对象序列化和反序列化

zookeeper实现分布式锁， curator

大文件上传和下载

过滤器和拦截器区别

数据库缓存

泛型擦除

逃逸分析 JIT

邮箱发送，短信发送，验证码

迪杰斯特拉算法

unsafe

怎么做一个starter

解析XML，DOM解析

spring加载bean文件

threadlocal限定

超卖问题

缓存资源

自动化执行脚本 139.Linux-23-项目部署_通过Shell脚本自动部署项目1(Av213091208,P139)

消息转化器，例如把对象传给前端时默认将所有的整型转化为字符串需求：34.业务开发Day2-21-启用、禁用员工账号_代码修复配置消息转换器(Av213091208,P34)

技能演练

- 过滤器 路径匹配器AntPathMatcher、filterChain、response.getWriter().write()
- mybatis
- 拦截器
- mybatis-plus，分页查询

jvm

- 70.23_垃圾回收器_吞吐量优先(Av70549061,P70)
- 78.31_G1_remark(Av70549061,P78)

### nacos config无法读取到nacos配置？

### 日常训练

反射

设计模式

类加载过程

mybatisplus

逻辑删除

每天常练egrep、sed、awk







## 面试

### 你遇到的最大的困难是什么？

之前上班接手的第一个项目，当时那个项目在我接受之前已经转手了三拨人，到我这里已经是第四波了，

### 自我介绍

面试官好，我叫黄达，来自江西九江，现在是华东师范大学计算机学院一名研二的学生，将于明年三月份毕业。

在校期间，

